---
title: kubernetes > rbac authorization in the cluster
categories: kubernetes
---

RBAC(Role Based Access Control) is one of the authorization modes supported by the Kube api server. And in this post we would see 
see some functionality of role and rolebinding objects that are used for ensuring RBAC in Kubernetes.

You should know how to launch a cluster using kubeadm, and how to create a user with TLS, to make the most use of this post.

This exercise is performed in a cluster launched with kubeadm, let's ensure we are in the right context, that ensures issuing kubectl commands 
as admin
```
networkandcode@k8s-master: $ kubectl config use-context kubernetes-admin@kubernetes
Switched to context "kubernetes-admin@kubernetes".
```

we can check if RBAC is enabled as follows
```
networkandcode@k8s-master: $ kubectl get po kube-apiserver-master -n kube-system -o yaml | grep authorization-mode
    - --authorization-mode=Node,RBAC
```
So both Node and RBAC authorization modes are enabled in the API server

Since RBAC is enabled, we could now go ahead and create a 'Role' object, which is specific to a namespace. Let's define 
a manifest
```
networkandcode@k8s-master: $ cat > role-get-pods.yaml <<EOF
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: get-pods
rules:
- apiGroups:
  - ""
  resources:
  - pods
  verbs:
  - list
...
EOF
```
The manifest above could be used to create a role with name 'get-pods' in the 'default' namespace. And this role 
should allow performing 'get' action on 'pods'. apiGroups refers to the list of apiGroups and since we are dealing 
only with Pods here, we just need mention "" for the core apiGroup. Note that apiGroup doesn't include the version as in
apiVersion. For instance if we have to refer to Deployments, whose apiVersion is apps/v1, the corresponding apiGroup would be "apps"

It's time to create the role
```
networkandcode@k8s-master: $ kubectl create -f role-get-pods.yaml

role.rbac.authorization.k8s.io/get-pods created

networkandcode@k8s-master: $ kubectl get roles
NAME       AGE
get-pods   24s
```

So the role, that can allow performing 'get' opertaion on 'Pods' is ready. But someone(for example a user) has to make use of this role. This is where 'rolebinding' 
comes into picture. We shall prepare a manifest for the 'rolebinding' object in the 'default' namespace
```
networkandcode@k8s-master: $ cat rolebinding-user2-get-pods.yaml
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: user2-get-pods
subjects:
- kind: User
  name: user2
  apiGroup: rbac.authorization.k8s.io
roleRef:
  kind: Role
  name: get-pods
  apiGroup: rbac.authorization.k8s.io
...
```

The rolebinding manifest above when applied, should map the subjects(in this case only user2) with the role 'get-pods' that was created already. 
Note that both 'role' and 'rolebinding' objects are scoped to a namespace. We may now create the rolebinding
```
networkandcode@k8s-master: $ kubectl create -f rolebinding-user2-get-pods.yaml
rolebinding.rbac.authorization.k8s.io/user2-get-pods created

networkandcode@k8s-master: $ kubectl get rolebindings
NAME             AGE
user2-get-pods   42s
```

user2 now has permission to issue 'kubectl get pods'. Let's switch the context to perfom actions as user2
```
networkandcode@k8s-master: $ kubectl config use-context context2
Switched to context "context2".
```
The context2 above scopes 'user2' with the current cluster 'kubernetes'. 
You  may refer to https://networkandcode.github.io/kubernetes/2020/02/27/add-a-kubectl-user-with-tls.html to setup a similar context

master $ kubectl get pods
No resources found.

So the rolebinding works as user2 is able to list pods in the default namespace. However it couldn't list nodes, as it doesn't have permission 
to do so
```
master $ kubectl get nodes
Error from server (Forbidden): nodes is forbidden: User "user2" cannot list resource "nodes" in API group "" at the cluster scope
```

So far we have seen binding a role with a user, and we were able to list Pods of a particular namespace (default). Let's say we want user2 to be 
able list all Pods of all namespaces, we would then need a clusterrole object which is cluster specific instead of a role object which is namespace specific.

--end-of-post--
